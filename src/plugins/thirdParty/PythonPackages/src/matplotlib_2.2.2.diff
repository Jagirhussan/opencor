diff --git lib/matplotlib/backends/backend_qt5.py lib/matplotlib/backends/backend_qt5.py
index 7fe7ff3a4..1638b4207 100644
--- lib/matplotlib/backends/backend_qt5.py
+++ lib/matplotlib/backends/backend_qt5.py
@@ -23,7 +23,7 @@ from matplotlib.backend_managers import ToolManager
 from matplotlib import backend_tools
 
 from .qt_compat import (
-    QtCore, QtGui, QtWidgets, _getSaveFileName, is_pyqt5, __version__, QT_API)
+    QtCore, QtGui, QtWidgets, _getSaveFileName, is_pyqt5, is_qt5, __version__, QT_API)
 
 backend_version = __version__
 
@@ -109,9 +109,9 @@ def _create_qApp():
 
     if qApp is None:
         app = QtWidgets.QApplication.instance()
-        if app is None:
+        if is_pyqt5() and app is None:
             # check for DISPLAY env variable on X11 build of Qt
-            if is_pyqt5():
+            if is_qt5():
                 try:
                     from PyQt5 import QtX11Extras
                     is_x11_build = True
@@ -129,7 +129,7 @@ def _create_qApp():
         else:
             qApp = app
 
-    if is_pyqt5():
+    if is_qt5():
         try:
             qApp.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps)
             qApp.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)
@@ -139,7 +139,7 @@ def _create_qApp():
 
 def _allow_super_init(__init__):
     """
-    Decorator for ``__init__`` to allow ``super().__init__`` on PyQt4/PySide2.
+    Decorator for ``__init__`` to allow ``super().__init__`` on PyQt4/PySide2/PythonQt.
     """
 
     if QT_API == "PyQt5":
@@ -147,8 +147,8 @@ def _allow_super_init(__init__):
         return __init__
 
     else:
-        # To work around lack of cooperative inheritance in PyQt4, PySide,
-        # and PySide2, when calling FigureCanvasQT.__init__, we temporarily
+        # To work around lack of cooperative inheritance in PyQt4, PySide, PySide2
+        # and PythonQt, when calling FigureCanvasQT.__init__, we temporarily
         # patch QWidget.__init__ by a cooperative version, that first calls
         # QWidget.__init__ with no additional arguments, and then finds the
         # next class in the MRO with an __init__ that does support cooperative
@@ -164,7 +164,7 @@ def _allow_super_init(__init__):
             next_coop_init = next(
                 cls for cls in mro[mro.index(QtWidgets.QWidget) + 1:]
                 if cls.__module__.split(".")[0] not in [
-                    "PyQt4", "sip", "PySide", "PySide2", "Shiboken"])
+                    "PyQt4", "sip", "PySide", "PySide2", "Shiboken", "PythonQt"])
             next_coop_init.__init__(self, *args, **kwargs)
 
         @functools.wraps(__init__)
@@ -542,8 +542,16 @@ class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):
 class MainWindow(QtWidgets.QMainWindow):
     closing = QtCore.Signal()
 
+    def __init__(self):
+        QtGui.QMainWindow.__init__(self)
+        self._closeCallbacks = []
+
+    def connectClosing(self, callback):
+        self._closeCallbacks.append(callback)
+
     def closeEvent(self, event):
-        self.closing.emit()
+        for callback in self._closeCallbacks:
+            callback()
         QtWidgets.QMainWindow.closeEvent(self, event)
 
 
@@ -566,8 +574,9 @@ class FigureManagerQT(FigureManagerBase):
         FigureManagerBase.__init__(self, canvas, num)
         self.canvas = canvas
         self.window = MainWindow()
-        self.window.closing.connect(canvas.close_event)
-        self.window.closing.connect(self._widgetclosed)
+        self.window.setAttribute(QtCore.Qt.WA_DeleteOnClose)
+        self.window.connectClosing(canvas.close_event)
+        self.window.connectClosing(self._widgetclosed)
 
         self.window.setWindowTitle("Figure %d" % num)
         image = os.path.join(matplotlib.rcParams['datapath'],
@@ -698,7 +707,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def __init__(self, canvas, parent, coordinates=True):
         """ coordinates: should we show the coordinates on the right? """
         self.canvas = canvas
-        self.parent = parent
+        self._parent = parent
         self.coordinates = coordinates
         self._actions = {}
         """A mapping of toolitem method names to their QActions"""
@@ -707,7 +716,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         NavigationToolbar2.__init__(self, canvas)
 
     def _icon(self, name):
-        if is_pyqt5():
+        if is_qt5():
             name = name.replace('.png', '_large.png')
         pm = QtGui.QPixmap(os.path.join(self.basedir, name))
         if hasattr(pm, 'setDevicePixelRatio'):
@@ -754,16 +763,16 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         # Esthetic adjustments - we need to set these explicitly in PyQt5
         # otherwise the layout looks different - but we don't want to set it if
         # not using HiDPI icons otherwise they look worse than before.
-        if is_pyqt5():
+        if is_qt5():
             self.setIconSize(QtCore.QSize(24, 24))
             self.layout().setSpacing(12)
 
-    if is_pyqt5():
+    if is_qt5():
         # For some reason, self.setMinimumHeight doesn't seem to carry over to
         # the actual sizeHint, so override it instead in order to make the
         # aesthetic adjustments noted above.
         def sizeHint(self):
-            size = super(NavigationToolbar2QT, self).sizeHint()
+            size = QtWidgets.QToolBar.sizeHint(self)
             size.setHeight(max(48, size.height()))
             return size
 
@@ -771,7 +780,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         allaxes = self.canvas.figure.get_axes()
         if not allaxes:
             QtWidgets.QMessageBox.warning(
-                self.parent, "Error", "There are no axes to edit.")
+                self._parent, "Error", "There are no axes to edit.")
             return
         elif len(allaxes) == 1:
             axes, = allaxes
@@ -785,7 +794,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
                             type(axes).__name__, id(axes)))
                 titles.append(name)
             item, ok = QtWidgets.QInputDialog.getItem(
-                self.parent, 'Customize', 'Select axes:', titles, 0, False)
+                self._parent, 'Customize', 'Select axes:', titles, 0, False)
             if ok:
                 axes = allaxes[titles.index(six.text_type(item))]
             else:
@@ -827,7 +836,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def configure_subplots(self):
         image = os.path.join(matplotlib.rcParams['datapath'],
                              'images', 'matplotlib.png')
-        dia = SubplotToolQt(self.canvas.figure, self.parent)
+        dia = SubplotToolQt(self.canvas.figure, self._parent)
         dia.setWindowIcon(QtGui.QIcon(image))
         dia.exec_()
 
@@ -849,7 +858,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
             filters.append(filter)
         filters = ';;'.join(filters)
 
-        fname, filter = _getSaveFileName(self.parent,
+        fname, filter = _getSaveFileName(self._parent,
                                          "Choose a filename to save to",
                                          start, filters, selectedFilter)
         if fname:
diff --git lib/matplotlib/backends/qt_compat.py lib/matplotlib/backends/qt_compat.py
index 86beaf97a..2804c60c2 100644
--- lib/matplotlib/backends/qt_compat.py
+++ lib/matplotlib/backends/qt_compat.py
@@ -18,9 +18,11 @@ QT_API_PYQTv2 = 'PyQt4v2'   # forced to Version 2 API
 QT_API_PYSIDE = 'PySide'    # only supports Version 2 API
 QT_API_PYQT5 = 'PyQt5'      # use PyQt5 API; Version 2 with module shim
 QT_API_PYSIDE2 = 'PySide2'  # Version 2 API with module shim
+QT_API_PYTHONQT = 'PythonQt' # use PythonQt API for Qt5
 
 ETS = dict(pyqt=(QT_API_PYQTv2, 4), pyside=(QT_API_PYSIDE, 4),
-           pyqt5=(QT_API_PYQT5, 5), pyside2=(QT_API_PYSIDE2, 5))
+           pyqt5=(QT_API_PYQT5, 5), pyside2=(QT_API_PYSIDE2, 5),
+           pythonqt=(QT_API_PYTHONQT, 5))
 # ETS is a dict of env variable to (QT_API, QT_MAJOR_VERSION)
 # If the ETS QT_API environment variable is set, use it, but only
 # if the varible if of the same major QT version.  Note that
@@ -66,14 +68,18 @@ if 'PyQt5' in sys.modules:
     # the user has imported PyQt5 before importing mpl
     QT_API = QT_API_PYQT5
 
+if 'PythonQt' in sys.modules:
+    # the user has imported PyQt5 before importing mpl
+    QT_API = QT_API_PYTHONQT
+
 if (QT_API_ENV is not None) and QT_API is None:
     try:
         QT_ENV_MAJOR_VERSION = ETS[QT_API_ENV][1]
     except KeyError:
         raise RuntimeError(
             ('Unrecognized environment variable %r, valid values are:'
-             ' %r, %r, %r or %r'
-             % (QT_API_ENV, 'pyqt', 'pyside', 'pyqt5', 'pyside2')))
+             ' %r, %r, %r, %r or %r'
+             % (QT_API_ENV, 'pyqt', 'pyside', 'pyqt5', 'pyside2', 'pythonqt')))
     if QT_ENV_MAJOR_VERSION == QT_RC_MAJOR_VERSION:
         # Only if backend and env qt major version are
         # compatible use the env variable.
@@ -210,9 +216,32 @@ if QT_API == QT_API_PYSIDE:  # try importing pyside
 
     _getSaveFileName = QtGui.QFileDialog.getSaveFileName
 
+elif QT_API == QT_API_PYTHONQT:  # try importing PythonQt
+    from PythonQt import QtCore, QtGui
+    __version__ = "3.2"
+    __version_info__ = "-"
+
+    # PythonQt does not yet support a getSaveFileName variant returning the selected filter
+    def _getSaveFileName(*args, **kwargs):
+        return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None)
+
+    # Provide color getters
+    def getHslF(c):
+        return (c.hslHueF(), c.hslSaturationF(), c.lightnessF(), c.alphaF())
+
+    def getHsvF(c):
+        return (c.hueF(), c.saturationF(), c.valueF(), c.alphaF())
+
+    def getRgbF(c):
+        return (c.redF(), c.greenF(), c.blueF(), c.alphaF())
+
+    QtGui.QColor.getHslF = getHslF
+    QtGui.QColor.getHsvF = getHsvF
+    QtGui.QColor.getRgbF = getRgbF
+
 
 # Apply shim to Qt4 APIs to make them look like Qt5
-if QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):
+if QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE, QT_API_PYTHONQT):
     '''Import all used QtGui objects into QtWidgets
 
     Here I've opted to simple copy QtGui into QtWidgets as that
@@ -223,5 +252,8 @@ if QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):
     QtWidgets = QtGui
 
 
+def is_qt5():
+    return QT_API in [QT_API_PYQT5, QT_API_PYTHONQT]
+
 def is_pyqt5():
     return QT_API == QT_API_PYQT5
diff --git lib/matplotlib/backends/qt_editor/formlayout.py lib/matplotlib/backends/qt_editor/formlayout.py
index d5fcdfc90..68e7dc963 100644
--- lib/matplotlib/backends/qt_editor/formlayout.py
+++ lib/matplotlib/backends/qt_editor/formlayout.py
@@ -72,8 +72,9 @@ class ColorButton(QtWidgets.QPushButton):
 
     def choose_color(self):
         color = QtWidgets.QColorDialog.getColor(
-            self._color, self.parentWidget(), "",
-            QtWidgets.QColorDialog.ShowAlphaChannel)
+            self._color, self.parentWidget(), "")
+        ## PythonQt doesn't support QColorDialog.ColorDialogOptions
+        ##    QtWidgets.QColorDialog.ShowAlphaChannel)
         if color.isValid():
             self.set_color(color)
 
@@ -205,7 +206,7 @@ class FontLayout(QtWidgets.QGridLayout):
 
 def is_edit_valid(edit):
     text = edit.text()
-    state = edit.validator().validate(text, 0)[0]
+    state = edit.validator().validate(text, 0)
 
     return state == QtGui.QDoubleValidator.Acceptable
 
diff --git lib/matplotlib/backends/qt_editor/formsubplottool.py lib/matplotlib/backends/qt_editor/formsubplottool.py
index 4906af588..7ffd956dc 100644
--- lib/matplotlib/backends/qt_editor/formsubplottool.py
+++ lib/matplotlib/backends/qt_editor/formsubplottool.py
@@ -54,3 +54,9 @@ class UiSubplotTool(QtWidgets.QDialog):
             right.addWidget(widget)
 
         self._widgets["Close"].setFocus()
+
+    def accept(self):
+        QtWidgets.QDialog.accept(self)
+
+    def close(self):
+        QtWidgets.QDialog.close(self)
