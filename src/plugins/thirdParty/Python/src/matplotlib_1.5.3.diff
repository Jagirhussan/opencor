################################################################################
##
##  Modifications to the Qt5 backend so that it can be used with PythonQt
##  ---------------------------------------------------------------------
##
##  Based on the discussion at
##  https://sourceforge.net/p/pythonqt/discussion/631393/thread/7b5e4b43/
##  and Florian Link's comment of 2012-07-18:
##
##      MeVisLab 2.3 contains a matplotlib backend that was ported to PythonQt,
##      by coincidence I did that port. It is not implemented as a full backend
##      of its own, just a patch that replaces calls to PyQt/PySide with
##      PythonQt in the Qt4 backend.
##
##      I did not have time to clean it up and to provide it back to the
##      matplotlib community. It is fully functional except for the figure
##      options dialog.
##
##      You can get it by downloading MeVisLab 2.3 RC and going to::
##
##          INSTALLDIR/Packages/MeVis/ThirdParty/Python/.../Libs/matplotlib/...
##
##          (or Libs/site-packages if you are downloading 2.3 Stable Release)
##
##      and taking the matplotlib/backends/ directory. You can diff that against
##      your matplotlib version to see the changes.
##
##  This diff is a diff of https://github.com/dbrnz/matplotlib/tree/PythonQt_v1.5.3
##  against the `v1.5.3` tag, https://github.com/matplotlib/matplotlib/tree/v1.5.3
##
##      git diff --no-prefix v1.5.3 PythonQt_v1.5.3
##
################################################################################
##
diff --git lib/matplotlib/backend_bases.py lib/matplotlib/backend_bases.py
index 31e47a4..db6ff60 100644
--- lib/matplotlib/backend_bases.py
+++ lib/matplotlib/backend_bases.py
@@ -1678,6 +1678,7 @@ class FigureCanvasBase(object):
                          'Tagged Image File Format')

     def __init__(self, figure):
+        super(FigureCanvasBase, self).__init__()
         self._is_idle_drawing = True
         self._is_saving = False
         figure.set_canvas(self)
@@ -2589,6 +2590,7 @@ class FigureManagerBase(object):
         The figure number
     """
     def __init__(self, canvas, num):
+        super(FigureManagerBase, self).__init__()
         self.canvas = canvas
         canvas.manager = self  # store a pointer to parent
         self.num = num
diff --git lib/matplotlib/backends/backend_qt5.py lib/matplotlib/backends/backend_qt5.py
index f92c06f..508430b 100644
--- lib/matplotlib/backends/backend_qt5.py
+++ lib/matplotlib/backends/backend_qt5.py
@@ -24,6 +24,7 @@ from matplotlib.figure import Figure

 from matplotlib.widgets import SubplotTool
 try:
+    raise ImportError # TODO: disabled figureoptions since they require some rework to make them work with PythonQt
     import matplotlib.backends.qt_editor.figureoptions as figureoptions
 except ImportError:
     figureoptions = None
@@ -215,8 +216,9 @@ class TimerQT(TimerBase):
     def _timer_stop(self):
         self._timer.stop()

-
-class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):
+# PythonQt stops initialising superclasses after one of its classes
+# so we've changed the order...
+class FigureCanvasQT(FigureCanvasBase, QtWidgets.QWidget):

     # map Qt button codes to MouseEvent's ones:
     buttond = {QtCore.Qt.LeftButton: 1,
@@ -418,8 +420,16 @@ class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):
 class MainWindow(QtWidgets.QMainWindow):
     closing = QtCore.Signal()

+    def __init__(self):
+        QtGui.QMainWindow.__init__(self)
+        self._closeCallbacks = []
+
+    def connectClosing(self, callback):
+        self._closeCallbacks.append(callback)
+
     def closeEvent(self, event):
-        self.closing.emit()
+        for callback in self._closeCallbacks:
+            callback()
         QtWidgets.QMainWindow.closeEvent(self, event)


@@ -436,11 +446,12 @@ class FigureManagerQT(FigureManagerBase):
     def __init__(self, canvas, num):
         if DEBUG:
             print('FigureManagerQT.%s' % fn_name())
-        FigureManagerBase.__init__(self, canvas, num)
+        super(FigureManagerQT, self).__init__(canvas, num)
         self.canvas = canvas
         self.window = MainWindow()
-        self.window.closing.connect(canvas.close_event)
-        self.window.closing.connect(self._widgetclosed)
+        self.window.setAttribute(QtCore.Qt.WA_DeleteOnClose)
+        self.window.connectClosing(canvas.close_event)
+        self.window.connectClosing(self._widgetclosed)

         self.window.setWindowTitle("Figure %d" % num)
         image = os.path.join(matplotlib.rcParams['datapath'],
@@ -466,15 +477,15 @@ class FigureManagerQT(FigureManagerBase):
         self.toolbar = self._get_toolbar(self.canvas, self.window)
         if self.toolbar is not None:
             self.window.addToolBar(self.toolbar)
-            self.toolbar.message.connect(self.statusbar_label.setText)
-            tbs_height = self.toolbar.sizeHint().height()
+            #self.toolbar.message.connect(self.statusbar_label.setText)
+            tbs_height = self.toolbar.sizeHint.height()
         else:
             tbs_height = 0

         # resize the main window so it will display the canvas with the
         # requested size:
         cs = canvas.sizeHint()
-        sbs = self.window.statusBar().sizeHint()
+        sbs = self.window.statusBar().sizeHint
         self._status_and_tool_height = tbs_height + sbs.height()
         height = cs.height() + self._status_and_tool_height
         self.window.resize(cs.width(), height)
@@ -553,7 +564,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def __init__(self, canvas, parent, coordinates=True):
         """ coordinates: should we show the coordinates on the right? """
         self.canvas = canvas
-        self.parent = parent
+        self._parent = parent
         self.coordinates = coordinates
         self._actions = {}
         """A mapping of toolitem method names to their QActions"""
@@ -607,7 +618,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
             allaxes = self.canvas.figure.get_axes()
             if not allaxes:
                 QtWidgets.QMessageBox.warning(
-                    self.parent, "Error", "There are no axes to edit.")
+                    self._parent, "Error", "There are no axes to edit.")
                 return
             if len(allaxes) == 1:
                 axes = allaxes[0]
@@ -632,7 +643,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
                                          ylabel=ylabel, label=label,
                                          axes_repr=repr(axes)))
                 item, ok = QtWidgets.QInputDialog.getItem(
-                    self.parent, 'Customize', 'Select axes:', titles, 0, False)
+                    self._parent, 'Customize', 'Select axes:', titles, 0, False)
                 if ok:
                     axes = allaxes[titles.index(six.text_type(item))]
                 else:
@@ -657,7 +668,8 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
         self.canvas.draw_idle()

     def set_message(self, s):
-        self.message.emit(s)
+        # TODO:
+        #self.message.emit(s)
         if self.coordinates:
             self.locLabel.setText(s)

@@ -683,7 +695,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
     def configure_subplots(self):
         image = os.path.join(matplotlib.rcParams['datapath'],
                              'images', 'matplotlib.png')
-        dia = SubplotToolQt(self.canvas.figure, self.parent)
+        dia = SubplotToolQt(self.canvas.figure, self._parent)
         dia.setWindowIcon(QtGui.QIcon(image))
         dia.exec_()

@@ -706,7 +718,7 @@ class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):
             filters.append(filter)
         filters = ';;'.join(filters)

-        fname, filter = _getSaveFileName(self.parent,
+        fname, filter = _getSaveFileName(self._parent,
                                          "Choose a filename to save to",
                                  start, filters, selectedFilter)
         if fname:
@@ -730,7 +742,7 @@ class SubplotToolQt(SubplotTool, UiSubplotTool):
         UiSubplotTool.__init__(self, None)

         self.targetfig = targetfig
-        self.parent = parent
+        self._parent = parent
         self.donebutton.clicked.connect(self.close)
         self.resetbutton.clicked.connect(self.reset)
         self.tightlayout.clicked.connect(self.functight)
@@ -762,7 +774,7 @@ class SubplotToolQt(SubplotTool, UiSubplotTool):
             slider.setSliderPosition(int(self.defaults[attr] * 1000))

     def funcleft(self, val):
-        if val == self.sliderright.value():
+        if val == self.sliderright.value:
             val -= 1
         val /= 1000.
         self.targetfig.subplots_adjust(left=val)
@@ -771,7 +783,7 @@ class SubplotToolQt(SubplotTool, UiSubplotTool):
             self.targetfig.canvas.draw_idle()

     def funcright(self, val):
-        if val == self.sliderleft.value():
+        if val == self.sliderleft.value:
             val += 1
         val /= 1000.
         self.targetfig.subplots_adjust(right=val)
@@ -780,7 +792,7 @@ class SubplotToolQt(SubplotTool, UiSubplotTool):
             self.targetfig.canvas.draw_idle()

     def funcbottom(self, val):
-        if val == self.slidertop.value():
+        if val == self.slidertop.value:
             val -= 1
         val /= 1000.
         self.targetfig.subplots_adjust(bottom=val)
@@ -789,7 +801,7 @@ class SubplotToolQt(SubplotTool, UiSubplotTool):
             self.targetfig.canvas.draw_idle()

     def functop(self, val):
-        if val == self.sliderbottom.value():
+        if val == self.sliderbottom.value:
             val += 1
         val /= 1000.
         self.targetfig.subplots_adjust(top=val)
diff --git lib/matplotlib/backends/backend_qt5agg.py lib/matplotlib/backends/backend_qt5agg.py
index fcb3c47..37e22c8 100644
--- lib/matplotlib/backends/backend_qt5agg.py
+++ lib/matplotlib/backends/backend_qt5agg.py
@@ -6,7 +6,6 @@ from __future__ import (absolute_import, division, print_function,

 from matplotlib.externals import six

-import ctypes
 import sys
 import traceback

@@ -28,10 +27,6 @@ from .qt_compat import QT_API

 DEBUG = False

-_decref = ctypes.pythonapi.Py_DecRef
-_decref.argtypes = [ctypes.py_object]
-_decref.restype = None
-

 def new_figure_manager(num, *args, **kwargs):
     """
@@ -90,12 +85,10 @@ class FigureCanvasQTAggBase(object):
             # into argb format and is in a 4 byte unsigned int.  Little endian
             # system is LSB first and expects the bytes in reverse order
             # (bgra).
-            if QtCore.QSysInfo.ByteOrder == QtCore.QSysInfo.LittleEndian:
-                stringBuffer = self.renderer._renderer.tostring_bgra()
-            else:
-                stringBuffer = self.renderer._renderer.tostring_argb()
-
-            refcnt = sys.getrefcount(stringBuffer)
+#            if QtCore.QSysInfo.ByteOrder == QtCore.QSysInfo.LittleEndian:
+            stringBuffer = self.renderer._renderer.tostring_bgra()
+#            else:
+#                stringBuffer = self.renderer._renderer.tostring_argb()

             # convert the Agg rendered image -> qImage
             qImage = QtGui.QImage(stringBuffer, self.renderer.width,
@@ -116,13 +109,7 @@ class FigureCanvasQTAggBase(object):
                 p.drawRect(x, y, w, h)
             p.end()

-            # This works around a bug in PySide 1.1.2 on Python 3.x,
-            # where the reference count of stringBuffer is incremented
-            # but never decremented by QImage.
-            # TODO: revert PR #1323 once the issue is fixed in PySide.
             del qImage
-            if refcnt != sys.getrefcount(stringBuffer):
-                _decref(stringBuffer)
         else:
             bbox = self.blitbox
             l, b, r, t = bbox.extents
@@ -173,7 +160,7 @@ class FigureCanvasQTAggBase(object):
             QtCore.QTimer.singleShot(0, self.__draw_idle_agg)

     def __draw_idle_agg(self, *args):
-        if self.height() < 0 or self.width() < 0:
+        if self.height < 0 or self.width < 0:
             self._agg_draw_pending = False
             return
         try:
diff --git lib/matplotlib/backends/qt_compat.py lib/matplotlib/backends/qt_compat.py
index 0546bdc..6538382 100644
--- lib/matplotlib/backends/qt_compat.py
+++ lib/matplotlib/backends/qt_compat.py
@@ -14,9 +14,10 @@ QT_API_PYQT = 'PyQt4'       # API is not set here; Python 2.x default is V 1
 QT_API_PYQTv2 = 'PyQt4v2'   # forced to Version 2 API
 QT_API_PYSIDE = 'PySide'    # only supports Version 2 API
 QT_API_PYQT5 = 'PyQt5'       # use PyQt5 API; Version 2 with module shim
+QT_API_PYTHONQT = 'PythonQt' # use PythonQt API for Qt5

 ETS = dict(pyqt=(QT_API_PYQTv2, 4), pyside=(QT_API_PYSIDE, 4),
-           pyqt5=(QT_API_PYQT5, 5))
+           pyqt5=(QT_API_PYQT5, 5), pythonqt=(QT_API_PYTHONQT, 5))
 # ETS is a dict of env variable to (QT_API, QT_MAJOR_VERSION)
 # If the ETS QT_API environment variable is set, use it, but only
 # if the varible if of the same major QT version.  Note that
@@ -58,6 +59,10 @@ if 'PyQt5' in sys.modules:
     # the user has imported PyQt5 before importing mpl
     QT_API = QT_API_PYQT5

+if 'PythonQt' in sys.modules:
+    # the user has imported PyQt5 before importing mpl
+    QT_API = QT_API_PYTHONQT
+
 if (QT_API_ENV is not None) and QT_API is None:
     try:
         QT_ENV_MAJOR_VERSION = ETS[QT_API_ENV][1]
@@ -181,9 +186,20 @@ if QT_API == QT_API_PYSIDE:  # try importing pyside

     _getSaveFileName = QtGui.QFileDialog.getSaveFileName

+elif QT_API == QT_API_PYTHONQT:  # try importing PythonQt
+    from PythonQt import QtCore, QtGui
+    __version__ = "3.1"
+    __version_info__ = "-"
+
+    QtCore.Signal = lambda *x: NotImplemented
+
+    # PythonQt does not yet support a getSaveFileName variant returning the selected filter
+    def _getSaveFileName(*args, **kwargs):
+        return (QtGui.QFileDialog.getSaveFileName(*args, **kwargs), None)
+

 # Apply shim to Qt4 APIs to make them look like Qt5
-if QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE):
+if QT_API in (QT_API_PYQT, QT_API_PYQTv2, QT_API_PYSIDE, QT_API_PYTHONQT):
     '''Import all used QtGui objects into QtWidgets

     Here I've opted to simple copy QtGui into QtWidgets as that
diff --git lib/matplotlib/backends/qt_editor/formlayout.py lib/matplotlib/backends/qt_editor/formlayout.py
index 4e9a273..1b738d9 100644
--- lib/matplotlib/backends/qt_editor/formlayout.py
+++ lib/matplotlib/backends/qt_editor/formlayout.py
@@ -90,16 +90,16 @@ class ColorButton(QtWidgets.QPushButton):
     def get_color(self):
         return self._color

-    @QtCore.Slot(QtGui.QColor)
+    #@QtCore.Slot(QtGui.QColor)
     def set_color(self, color):
         if color != self._color:
             self._color = color
-            self.colorChanged.emit(self._color)
+            #self.colorChanged.emit(self._color)
             pixmap = QtGui.QPixmap(self.iconSize())
             pixmap.fill(color)
             self.setIcon(QtGui.QIcon(pixmap))

-    color = QtCore.Property(QtGui.QColor, get_color, set_color)
+    #color = QtCore.Property(QtGui.QColor, get_color, set_color)

 def col2hex(color):
     """Convert matplotlib color to hex before passing to Qt"""
@@ -140,7 +140,7 @@ class ColorLayout(QtWidgets.QHBoxLayout):
         self.lineedit.setText(color.name())

     def text(self):
-        return self.lineedit.text()
+        return self.lineedit.text


 def font_is_installed(font):
@@ -153,6 +153,8 @@ def tuple_to_qfont(tup):
     """
     Create a QFont from tuple:
         (family [string], size [int], italic [bool], bold [bool])
+
+    TODO: font_is_installed will currently not work due to missing QFontDatabase
     """
     if not isinstance(tup, tuple) or len(tup) != 4 \
        or not font_is_installed(tup[0]) \
@@ -217,7 +219,7 @@ class FontLayout(QtWidgets.QGridLayout):


 def is_edit_valid(edit):
-    text = edit.text()
+    text = edit.text
     state = edit.validator().validate(text, 0)[0]

     return state == QtGui.QDoubleValidator.Acceptable
@@ -327,9 +329,9 @@ class FormWidget(QtWidgets.QWidget):
             elif tuple_to_qfont(value) is not None:
                 value = field.get_font()
             elif isinstance(value, six.string_types) or is_color_like(value):
-                value = six.text_type(field.text())
+                value = six.text_type(field.text)
             elif isinstance(value, (list, tuple)):
-                index = int(field.currentIndex())
+                index = int(field.currentIndex)
                 if isinstance(value[0], (list, tuple)):
                     value = value[index][0]
                 else:
@@ -337,7 +339,7 @@ class FormWidget(QtWidgets.QWidget):
             elif isinstance(value, bool):
                 value = field.checkState() == QtCore.Qt.Checked
             elif isinstance(value, float):
-                value = float(str(field.text()))
+                value = float(str(field.text))
             elif isinstance(value, int):
                 value = int(field.value())
             elif isinstance(value, datetime.datetime):
@@ -345,7 +347,7 @@ class FormWidget(QtWidgets.QWidget):
             elif isinstance(value, datetime.date):
                 value = field.date().toPyDate()
             else:
-                value = eval(str(field.text()))
+                value = eval(str(field.text))
             valuelist.append(value)
         return valuelist

